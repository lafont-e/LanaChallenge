This challenge is solved with 6 entities

- discounts: it is a function that given a ticket and a line from such ticket computes the discount appliable if any.
- promotions: table of promotions offered on products by the shop.
- products: Table of products that are sold on the store, only defined as name and price.
- line: each and every one of the product sold in a ticket, a line defines the product and the quantity.
- tickets: Collection of lines reflecting the products sold in this ticket.
- currency: an integer that shows himself as a float, every price in the application is processed as an integer

* As we don't have a database where to keep permanent information, we used global variables as an alternative, although global variables (an more in modules) are a bad programming practice, I'm aware of it, but this is a sample application only, so it makes no sense to define a database and use it.
* in discounts, the discount functions are hard coded BUT with a small change, they can be loaded dinamically (golang plugin) at runtime if needed, just did not implement that way as it takes more effort
* the files promotions.json and products.json must be available at the same directory that the server application.

* Tickets has the followind public functions/methods
- NewTicket: returns a new ticket with the given promotions table
- Add: method that adds a line to the ticket
- Total: total value of the ticket 
- Status : status info of the ticket, used only to somewhat identify a ticket for the http server
- String : returns a string representing the ticket in print format

* Server is a REST HTTP Server that recognices the following methods
- GET  /newticket     Creates a new ticket
- GET  /tickets       List all tickets stored on the server
- GET  /ticket/[0-9]+ Retrieves the ticket asked
- POST /ticket/[0-9]+ Used to add lines to a ticket, the body represents a Form with the needed parameters

* bin/Server is the application that launches the ticket server
* bin/Client is the application that connects through REST with the ticket server
* commands runs from the bin directory where the needed json files reside, there are copies of those files on tickets and server but mostly to make the tests work

* promotions.json and products.json files should be on a conf directory, or named through a conf file, but I did not pretend a fully functional app, just a pilot tests

* there is a Makefile to simplify the process, it compiles and installs the binaries in the bin directory
- make all, will compile and install client & server apps to the bin directory
- From the bin directory, calling server will wake up the tickets server
- From the bin directory, calling client will call the ticket server

* Available commands of the client app
- new , will create a new ticket
- list, will list all tickets on the ticket server
- show, will show any asked ticket (use the -t flag, otherwise only ticket 0 will be shown)
- add,  will add a product to a ticket (use the -t, -p and -q flags)


* The code "as is", is scalable, I mean, every request to the server is processed by a goroutine, and processing inside a ticket is locked on critical parts, I'm not a big fan of locks, but the alternative was to make the code more complicated.
* About expanding the promotions, it's simple, just add a function that creates the discounts needed based on the lines afected by the promotion, and add that function to the promotions map and the promotions.json
* The promotion model allows discounts on total quantity and can be expanded to mixing products, ie: buy any product and get the next one free (paying the more expensive one) 

* The mess on the git history log, is due to a problem I had with my old github repository, so I needed to move all to a new repository and that created the garbage in the log. Could have done a rebase to make it clear, but wanted to show the whole log as it was.